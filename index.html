<!-- <!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="styles/styles.css">
    <title>Bootstrap Grid</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <style>
       
    </style>
</head>
<body>

    <div class="container">
        <div class="row">

            <div class="col-lg-8 col-md-7 col-12">
                <canvas id="canvas"></canvas>
            </div>

            <div class="col-lg-4 col-md-5 col-12">
                <div class="box tall-box w-100 h-100"></div>
            </div>
        </div>
        <div class="row mt-2">

            <div class="col-3">
                <div class="box small-box small-box2 w-100"></div>
            </div>
            <div class="col-5">
                <div class="box small-box w-100"></div>
            </div>
            <div class="col-4">
                <div class="box small-box w-100"></div>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>
    <script src="scripts/game.js"></script>
</body>
</html> -->

<!doctype html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <title>Making your first Phaser 3 Game - Part 10</title>
    <script src="//cdn.jsdelivr.net/npm/phaser@3.11.0/dist/phaser.js"></script>
    <link rel="stylesheet" href="styles/styles.css">
    <link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">

</head>

<body>

    <audio id="backgroundMusic" src="Sounds/MusicaPrincipal.mp3" loop></audio>

    <div class="container">
        <div class="row">

            <div class="col-lg-8 col-md-7 col-12">
                <canvas id="canvas"></canvas>
            </div>

            <div class="col-lg-4 col-md-5 col-12">
                <div class="box tall-box w-100 h-100"></div>
            </div>
        </div>
        <div class="row mt-2">
            <div class="col-3">
                <div class="box small-box small-box2 w-100"></div>
            </div>
            <div class="col-5">
                <div class="Vidas box small-box w-100">
                    <div id="lives-container"></div><!--Contenedor para las vidas-->
                </div>
            </div>
            <div class="col-4">
                <div class="box small-box w-100">
                    <img id="toggleMusicBtn" src="assets/btn.png" alt="Toggle Music"
                        style="width:80px; cursor:pointer;">

                    <!-- Botón para Pausar el Juego -->
                    <img id="pauseGameBtn" src="assets/btn.png" alt="Pause Game" style="width:80px; cursor:pointer;">

                    <!-- Botón para Salir al Menú -->
                    <img id="exitGameBtn" src="assets/btn.png" alt="Exit Game" style="width:80px; cursor:pointer;">
                </div>
            </div>
        </div>
    </div>


    <!-- <script src="/scripts/NextLevel.js"></script> -->
    <script src="scripts/opciones.js"></script>
    <script type="text/javascript">

        class NextLevel extends Phaser.Scene {
            constructor() {
                super({ key: 'NextLevel' });
            }

            getPlayersFromStorage() {
                let players = localStorage.getItem('players');
                return players ? JSON.parse(players) : [];
            }

            preload() {
                this.load.image('sky', 'assets/sky.png');
                this.load.image('ground', 'assets/platform.png');
                this.load.image('bomb', 'assets/bomb.png');
                this.load.image('star', 'assets/star.png');
                this.load.spritesheet('dude', 'assets/dude.png', { frameWidth: 32, frameHeight: 48 });
            }

            create() {
                // Hacer el nivel mucho más largo
                let levelWidth = this.sys.game.config.width * 4; // 4 veces el ancho de la pantalla
                // Mapear 'player1' y 'player2' a sus respectivas spritesheets

                // Crear fondo infinito con tileSprite
                this.sky = this.add.tileSprite(0, 0, this.sys.game.config.width, this.sys.game.config.height, 'sky')
                    .setOrigin(0, 0)
                    .setScrollFactor(0) // Hace que se quede fijo en la cámara
                    .setDepth(-3); // Detrás de todo

                // Crear montañas de fondo con tileSprite
                this.mountains = this.add.tileSprite(0, this.sys.game.config.height - 200, this.sys.game.config.width, 200, 'mountain')
                    .setOrigin(0, 1)
                    .setScrollFactor(0.5) // Se mueve más lento que el jugador para efecto de parallax
                    .setDepth(-2); // Detrás del jugador, pero delante del cielo

                let characterMap = {
                    player1: 'dude',
                    player2: 'dude1'
                };

                // Obtener la spritesheet correcta
                let selectedCharacter = localStorage.getItem('selectedCharacter') || 'dude';
                let characterKey = characterMap[selectedCharacter] || 'dude';  // Valor por defecto
                // Obtener el personaje seleccionado desde localStorage



                // Agregar el jugador a la escena con la imagen correcta
                // this.player = this.physics.add.sprite(100, 450, selectedCharacter);
                // this.player.setBounce(0.2);
                // this.player.setCollideWorldBounds(true);

                this.isGameOver = false; // El juego empieza en falso

                this.add.image(400, 300, 'sky');


                // Crear plataformas
                let platforms = this.physics.add.staticGroup();
                platforms.create(400, 568, 'ground').setScale(2).refreshBody();
                platforms.create(800, 568, 'ground').setScale(2).refreshBody();
                platforms.create(1200, 568, 'ground').setScale(2).refreshBody();
                platforms.create(1600, 568, 'ground').setScale(2).refreshBody();
                platforms.create(2000, 568, 'ground').setScale(2).refreshBody();
                platforms.create(2400, 568, 'ground').setScale(2).refreshBody();
                platforms.create(2800, 568, 'ground').setScale(2).refreshBody();
                platforms.create(3200, 568, 'ground').setScale(2).refreshBody();
                platforms.create(3600, 568, 'ground').setScale(2).refreshBody();
                platforms.create(4000, 568, 'ground').setScale(2).refreshBody();
                platforms.create(800, 450, 'ground');
                platforms.create(1200, 350, 'ground');
                platforms.create(1600, 250, 'ground');
                platforms.create(2000, 400, 'ground');
                platforms.create(2500, 500, 'ground');
                platforms.create(2500, 500, 'ground');

                this.specialItemGroup = this.physics.add.group();

                this.player = this.physics.add.sprite(100, 450, characterKey);
                this.player.setBounce(0.2);
                this.player.setCollideWorldBounds(true);


                if (!this.player) {
                    console.error("Error: this.player no se ha inicializado correctamente");
                }
                // Habilitar la colisión entre el jugador y las plataformas
                this.physics.add.collider(this.player, platforms);

                this.anims.create({
                    key: 'left',
                    frames: this.anims.generateFrameNumbers(characterKey, { start: 0, end: 3 }),
                    frameRate: 10,
                    repeat: -1
                });

                this.anims.create({
                    key: 'turn',
                    frames: [{ key: characterKey, frame: 4 }],
                    frameRate: 20
                });

                this.anims.create({
                    key: 'right',
                    frames: this.anims.generateFrameNumbers(characterKey, { start: 5, end: 8 }),
                    frameRate: 10,
                    repeat: -1
                });

                this.cursors = this.input.keyboard.createCursorKeys();

                this.stars = this.physics.add.group({
                    key: 'star',
                    repeat: 11,
                    setXY: { x: 12, y: 0, stepX: 70 }
                });

                this.stars.children.iterate(function (child) {
                    child.setBounceY(Phaser.Math.FloatBetween(0.4, 0.8));
                });

                this.bombs = this.physics.add.group();
                this.spawnBombs(3);

                // Vidas
                this.lives = 3;

                // Contenedor en el HTML donde se mostrarán las imágenes de las vidas
                this.livesContainer = document.getElementById("lives-container");

                // Cargar las imágenes de las vidas
                this.updateLivesUI();

                // Grupo de disparos
                this.bullets = this.physics.add.group();

                // Puntuación
                this.score = parseInt(localStorage.getItem('score')) || 0;
                this.scoreText = this.add.text(16, 16, `Score: ${this.score}`, { fontSize: '32px', fill: '#000' });

                this.physics.add.collider(this.player, platforms);
                this.physics.add.collider(this.stars, platforms);
                this.physics.add.collider(this.bombs, platforms);
                this.physics.add.overlap(this.player, this.stars, this.collectStar, null, this);
                this.physics.add.collider(this.player, this.bombs, this.hitBomb, null, this);
                this.physics.add.collider(this.specialItemGroup, platforms);



                // Tecla para disparar
                this.spaceKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);
                this.physics.add.overlap(this.bullets, this.bombs, this.hitEnemy, null, this);

                // Hacer que la camara siga al jugador
                this.cameras.main.startFollow(this.player);
                this.cameras.main.setBounds(0, 0, levelWidth, this.sys.game.config.height);

                // Asegurar que la cámara cubra todo el nivel
                this.cameras.main.setBounds(0, 0, levelWidth, this.sys.game.config.height);

                // Asegurar que el jugador pueda moverse dentro de los límites del mundo
                this.physics.world.setBounds(0, 0, levelWidth, this.sys.game.config.height);
                this.lastSpawnX = this.player.x; // Inicializar la última posición de spawn
            }

            update() {
                if (!this.player || this.isGameOver) return;


                this.sky.tilePositionX = this.cameras.main.scrollX;
                this.mountains.tilePositionX = this.cameras.main.scrollX * 0.5;


                let distanceThreshold = 500; // Cada cuántos píxeles se generan estrellas y bombas
                let nextSpawnX = this.lastSpawnX + distanceThreshold;

                if (this.player.x > nextSpawnX) {
                    this.lastSpawnX = this.player.x;

                    // Generar una nueva estrella
                    let starX = this.player.x + Phaser.Math.Between(100, 300);
                    let starY = Phaser.Math.Between(50, 300);
                    let newStar = this.stars.create(starX, starY, 'star');
                    newStar.setBounceY(Phaser.Math.FloatBetween(0.4, 0.8));
                    console.log("Nueva estrella");

                    // Generar una nueva bomba
                    let bombX = this.player.x + Phaser.Math.Between(200, 400);
                    let bomb = this.bombs.create(bombX, 16, 'bomb');
                    bomb.setBounce(1);
                    bomb.setCollideWorldBounds(true);
                    bomb.setVelocity(Phaser.Math.Between(-200, 200), 20);
                    console.log("Nueva bomba");
                }

                if (this.score >= 50 && !this.isGameOver) {
                    this.showCongratulations();
                    return;
                }


                if (this.cursors.left.isDown) {
                    this.player.setVelocityX(-160);
                    this.player.anims.play('left', true);
                } else if (this.cursors.right.isDown) {
                    this.player.setVelocityX(160);
                    this.player.anims.play('right', true);
                } else {
                    this.player.setVelocityX(0);
                    this.player.anims.play('turn');
                }

                if (this.cursors.up.isDown && this.player.body.touching.down) {
                    this.player.setVelocityY(-330);
                }

                // Detectar disparo
                if (Phaser.Input.Keyboard.JustDown(this.spaceKey)) {
                    this.shoot();
                }

                // ---- LÓGICA PARA APARECER EL OBJETO ESPECIAL ---
                if (!this.hasSpawnedSpecialItem && this.player.x >= 500) {
                    this.spawnSpecialItem();
                    this.hasSpawnedSpecialItem = true;
                }

                this.specialItemGroup.children.iterate(specialItem => {
                    if (specialItem.active && specialItem.countdownText) {
                        specialItem.countdownText.x = specialItem.x;
                        specialItem.countdownText.y = specialItem.y - 50;
                    }
                });
            }

            savePlayer(name, score) {
                let players = getPlayersFromStorage();

                // Buscar si el jugador ya existe
                let existingPlayer = players.find(player => player.name === name);

                if (existingPlayer) {
                    // Solo actualizar la puntuación si es mayor
                    if (score > existingPlayer.score) {
                        existingPlayer.score = score;
                    }
                } else {
                    // Agregar nuevo jugador con la fecha actual
                    players.push({
                        name,
                        score,
                        date: new Date().toLocaleDateString() // Guardar la fecha de registro
                    });
                }

                // Guardar en localStorage
                localStorage.setItem('players', JSON.stringify(players));

                // Actualizar tabla de puntuaciones
                this.updateScoreTable();
            }

            // Función para actualizar la tabla de puntuaciones
            updateScoreTable() {
                let players = getPlayersFromStorage();

                // Ordenar por puntuación de mayor a menor
                players.sort((a, b) => b.score - a.score);

                // Seleccionar el contenedor donde se insertará la tabla
                let scoreContainer = document.querySelector('.col-lg-4 .box');
                scoreContainer.innerHTML = `<h3>Puntuaciones</h3>
                                <table class="table table-dark">
                                    <thead>
                                        <tr>
                                            <th class="fs-2">Nombre</th>
                                            <th class="fs-2">Puntuación</th>
                                            <th class="fs-2">Fecha de Registro</th> <!-- Nueva columna -->
                                        </tr>
                                    </thead>
                                    <tbody>
                                    ${players.map(player => `
                                        <tr class="fs-4">
                                            <td>${player.name}</td>
                                            <td>${player.score}</td>
                                            <td>${player.date || 'N/A'}</td> <!-- Mostrar 'N/A' si no tiene fecha -->
                                        </tr>`).join('')}
                                    </tbody>
                                </table>`;
            }

            // ✅ **Función para disparar hacia la dirección del jugador**
            shoot = function () {
                if (this.isGameOver) return;

                let bullet = this.bullets.create(this.player.x, this.player.y, 'bomb');
                bullet.setScale(0.5);
                bullet.body.allowGravity = false;

                // Determinar la dirección del disparo
                let direction = this.player.anims.currentAnim.key === 'left' ? -1 : 1;
                bullet.setVelocityX(400 * direction);
            };

            spawnBombs = function () {
                for (let i = 0; i < 3; i++) { // Genera 2 bombas cada vez
                    let x = Phaser.Math.Between(100, 700);
                    let bomb = this.bombs.create(x, 16, 'bomb');
                    bomb.setBounce(1);
                    bomb.setCollideWorldBounds(true);
                    bomb.setVelocity(Phaser.Math.Between(-200, 200), 20);
                    bomb.health = 5;
                }
            };

            hitBomb = function (player, bomb) {
                // Reducir vida
                this.lives -= 1;

                // Actualizar la UI de vidas
                this.updateLivesUI();

                // Si las vidas llegan a 0, terminar el juego
                if (this.lives <= 0 && !this.isGameOver) {
                    this.gameOver();
                    console.log("Game Over");
                }
            };

            gameOver = function () {
                if (this.isGameOver) return; // Evita llamadas múltiples
                this.isGameOver = true; // Marcar el estado de game over

                // Pausa el jugador
                this.physics.pause();
                this.player.setTint(0xff0000);
                this.player.anims.play('turn');

                // Eliminar controles
                this.cursors.left.reset();
                this.cursors.right.reset();
                this.cursors.up.reset();

                // Mostrar el texto de Game Over
                let gameOverText = this.add.text(400, 200, 'GAME OVER', { fontSize: '48px', fill: '#f00' }).setOrigin(0.5);

                // Botón de reinicio
                let restartButton = this.add.text(400, 300, 'Reintentar', { fontSize: '32px', fill: '#0f0' })
                    .setInteractive()
                    .on('pointerdown', () => {

                        this.scene.restart();          // Reiniciar escena
                    });


                // Botón de menú
                let menuButton = this.add.text(400, 350, 'Menú Principal', { fontSize: '32px', fill: '#ff0' })
                    .setInteractive()
                    .setOrigin(0.5)
                    .on('pointerdown', () => {
                        this.scene.start('MenuScene');
                    });
            };

            updateLivesUI = function () {
                // Limpiar el contenedor antes de volver a renderizar las vidas
                this.livesContainer.innerHTML = "";

                // Agregar una imagen por cada vida restante
                for (let i = 0; i < this.lives; i++) {
                    let img = document.createElement("img");
                    img.src = "assets/bomb.png"; // Ruta correcta de la imagen de vida
                    img.classList.add("life-icon"); // Clase CSS para darle estilo
                    this.livesContainer.appendChild(img);
                }
            };

            spawnSpecialItem = function () {
                // Crea el ítem un poco adelante del jugador para que sea visible
                let x = this.player.x + Phaser.Math.Between(200, 400);
                let y = Phaser.Math.Between(50, 300);

                // Crea el sprite y lo añade al grupo
                let specialItem = this.specialItemGroup.create(x, y, 'specialItem');

                // Ajusta físicas
                specialItem.setBounce(0.5);
                specialItem.setCollideWorldBounds(true);
                // Haz que colisione con las plataformas
                this.physics.add.collider(specialItem, this.platforms);

                // Detectar colisión/solapamiento con el jugador
                this.physics.add.overlap(this.player, specialItem, this.collectSpecialItem, null, this);

                // --- CONTADOR SOBRE EL ÍTEM ---
                let timeLeft = 5; // (5 segundos)
                let countdownText = this.add.text(
                    specialItem.x,
                    specialItem.y - 50,
                    timeLeft,
                    { fontSize: '20px', fill: '#fff' }
                ).setOrigin(0.5);

                // Guarda la referencia en el propio ítem para manipularlo luego
                specialItem.countdownText = countdownText;
                specialItem.timeLeft = timeLeft;

                // Cada segundo, disminuimos el contador
                this.time.addEvent({
                    delay: 1000,
                    callback: () => {
                        // Si el ítem ya no existe (recogido o destruido), no hacemos nada
                        if (!specialItem.active) return;

                        specialItem.timeLeft--;
                        specialItem.countdownText.setText(specialItem.timeLeft);

                        if (specialItem.timeLeft <= 0) {
                            // Se acabó el tiempo: destruir ítem y su texto
                            specialItem.destroy();
                            specialItem.countdownText.destroy();
                            console.log("El objeto especial desapareció por tiempo.");
                        }
                    },
                    repeat: 4 // Repetimos 4 veces. (0 -> 5s totales)
                });
            };

            collectSpecialItem = function (player, specialItem) {
                // Desactivarlo inmediatamente (ya no colisiona)
                specialItem.disableBody(true, true);

                // Destruir el texto si existe
                if (specialItem.countdownText) {
                    specialItem.countdownText.destroy();
                }

                // Sumar 100 puntos al marcador
                this.score += 100;
                this.scoreText.setText(`Score: ${this.score}`);

                // (Opcional) Guardar en localStorage
                let playerName = localStorage.getItem('playerName') || "Jugador";
                savePlayer(playerName, this.score);

                console.log("¡Recogiste el objeto especial y ganaste 100 puntos!");
            };

            // Funcion para guardar la puntuación en localStorage
            collectStar = function (player, star) {
                star.disableBody(true, true);
                this.score += 10;

                // Guardar o actualizar la puntuación en localStorage
                let playerName = localStorage.getItem('playerName') || "Jugador";
                savePlayer(playerName, this.score);

                this.scoreText.setText(`Score: ${this.score}`);

                //Generar nuevas estrellas
                if (this.stars.countActive(true) === 0) {
                    this.stars.children.iterate(child => { child.enableBody(true, child.x, 0, true, true); });
                    this.spawnBombs();
                }
            };

            hitEnemy = function (bullet, bomb) {
                console.log("Impacto");

                bullet.destroy(); // Eliminar la bala

                if (bomb.health === undefined) {
                    bomb.health = 5; // Asignar vida
                }

                bomb.health -= 1;

                //Cambiar color al recibir daño 
                bomb.setTint(0xff0000);
                setTimeout(() => {
                    bomb.clearTint(); // Volver al color normal después de 200ms
                }, 200);

                if (bomb.health <= 0) {
                    bomb.destroy();
                    this.score += 20;
                    this.scoreText.setText(`Score: ${this.score}`);
                }
            };

            gameOver = function () {
                if (this.isGameOver) return; // Evita llamadas múltiples
                this.isGameOver = true; // Marcar el estado de game over

                // Pausa el jugador
                this.physics.pause();
                this.player.setTint(0xff0000);
                this.player.anims.play('turn');

                // Eliminar controles
                this.cursors.left.reset();
                this.cursors.right.reset();
                this.cursors.up.reset();

                // Mostrar el texto de Game Over
                let gameOverText = this.add.text(400, 200, 'GAME OVER', { fontSize: '48px', fill: '#f00' }).setOrigin(0.5);

                // Botón de reinicio
                let restartButton = this.add.text(400, 300, 'Reintentar', { fontSize: '32px', fill: '#0f0' })
                    .setInteractive()
                    .on('pointerdown', () => {

                        this.scene.restart();          // Reiniciar escena
                    });


                // Botón de menú
                let menuButton = this.add.text(400, 350, 'Menú Principal', { fontSize: '32px', fill: '#ff0' })
                    .setInteractive()
                    .setOrigin(0.5)
                    .on('pointerdown', () => {
                        this.scene.start('MenuScene');
                    });
            };

            showCongratulations = function () {
                this.isGameOver = true;  // Bloquear el juego para que no continúe mientras se muestra el mensaje

                // Detener la física y las animaciones
                this.physics.pause();
                this.player.setTint(0x00ff00);  // Puedes cambiar el color del jugador para dar efecto de "felicitación"

                // Mostrar el mensaje de felicitaciones
                let congratulationsText = this.add.text(400, 200, '¡Felicidades! Has alcanzado 1000 puntos.', {
                    fontSize: '48px',
                    fill: '#fff'
                }).setOrigin(0.5);

                // Botón de siguiente nivel
                let nextLevelButton = this.add.image(400, 300, 'nextLevelButton').setInteractive();
                nextLevelButton.on('pointerdown', () => {
                    this.startNextLevel();
                });

                // Botón de volver al menú
                let menuButton = this.add.image(400, 400, 'menuButton').setInteractive();
                menuButton.on('pointerdown', () => {
                    this.goToMainMenu();
                });
            };

            startNextLevel = function () {
                this.scene.start('NextLevel');
            };

            goToMainMenu = function () {
                this.scene.start('MenuScene');
            };

        }

        var container = document.getElementById('canvas').parentElement;

        var config = {
            type: Phaser.AUTO,
            width: 800,
            height: 600,
            physics: {
                default: 'arcade',
                arcade: {
                    gravity: { y: 300 },
                    debug: false
                }
            },
            scene: [MenuScene, PlayerSetupScene, GameScene, ControlsScene, CreditsScene, NextLevel],
            canvas: document.getElementById('canvas')
        };



        var game = new Phaser.Game(config);

        function MenuScene() {
            Phaser.Scene.call(this, { key: 'MenuScene' });
        }

        MenuScene.prototype = Object.create(Phaser.Scene.prototype);
        MenuScene.prototype.constructor = MenuScene;

        MenuScene.prototype.preload = function () {
            this.load.image('menuBackground', 'img/ImgHero.jpg'); // Fondo del menú
            this.load.image('playButton', 'assets/play_button.png'); // Botón jugar
            this.load.image('controlsButton', 'assets/controls_button.png'); // Botón controles
            this.load.image('creditsButton', 'assets/credits_button.png'); // Botón créditos
            this.load.audio('backgroundMusic', 'Sounds/MusicaPrincipal.mp3'); // Carga el archivo de audio

        };

        MenuScene.prototype.create = function () {
            // Agregar fondo
            let background = this.add.image(400, 300, 'menuBackground');
            background.setScale(
                this.sys.game.config.width / background.width,
                this.sys.game.config.height / background.height

            );


            var music = this.sound.add('backgroundMusic');
            music.play({
                loop: true
            });

            // Botón de jugar
            this.add.image(400, 350, 'playButton')
                .setInteractive()
                .on('pointerdown', () => this.scene.start('PlayerSetupScene'));

            // Botón de controles
            this.add.image(400, 400, 'controlsButton')
                .setInteractive()
                .on('pointerdown', () => this.scene.start('ControlsScene'));

            // Botón de créditos
            this.add.image(400, 450, 'creditsButton')
                .setInteractive()
                .on('pointerdown', () => this.scene.start('CreditsScene'));
        };

        // NUEVA ESCENA PARA CONFIGURAR JUGADOR
        function PlayerSetupScene() {
            Phaser.Scene.call(this, { key: 'PlayerSetupScene' });
        }

        PlayerSetupScene.prototype = Object.create(Phaser.Scene.prototype);
        PlayerSetupScene.prototype.constructor = PlayerSetupScene;

        PlayerSetupScene.prototype.preload = function () {
            this.load.image('player1', 'assets/dude.png');
            this.load.image('player2', 'assets/dude1.png');
        };

        PlayerSetupScene.prototype.create = function () {
            this.add.text(200, 100, 'Ingresa tu nombre:', { fontSize: '24px', fill: '#fff' });

            let inputElement = document.createElement('input');
            inputElement.type = 'text';
            inputElement.id = 'playerNameInput';
            inputElement.style.position = 'absolute';
            inputElement.style.top = '120px';
            inputElement.style.left = '300px';
            inputElement.style.width = '200px';
            document.body.appendChild(inputElement);

            this.add.text(200, 200, 'Selecciona tu personaje:', { fontSize: '24px', fill: '#fff' });

            let selectedCharacter = null;

            let player1 = this.add.image(300, 300, 'player1')
                .setInteractive()
                .on('pointerdown', () => {
                    selectedCharacter = 'player1';
                    player1.setTint(0x00ff00); // Resalta el seleccionado
                    player2.clearTint();
                });

            let player2 = this.add.image(500, 300, 'player2')
                .setInteractive()
                .on('pointerdown', () => {
                    selectedCharacter = 'player2';
                    player2.setTint(0x00ff00);
                    player1.clearTint();
                });

            let playButton = this.add.text(350, 400, 'Jugar', { fontSize: '24px', fill: '#0f0' })
                .setInteractive()
                .on('pointerdown', () => {
                    let playerName = inputElement.value.trim();
                    if (!/^[a-zA-Z]{4,8}$/.test(playerName)) {
                        alert('El nombre debe tener entre 4 y 8 letras.');
                        return;
                    }
                    if (!selectedCharacter) {
                        alert('Debes seleccionar un personaje.');
                        return;
                    }

                    // Guardar en localStorage
                    localStorage.setItem('playerName', playerName);
                    localStorage.setItem('selectedCharacter', selectedCharacter);
                    localStorage.setItem('score', 0); // Inicializa la puntuación

                    // Remover el input de la pantalla
                    document.body.removeChild(inputElement);

                    // Ir al juego
                    this.scene.start('GameScene');
                });
        };

        // Función para obtener los jugadores guardados en localStorage
        function getPlayersFromStorage() {
            let players = localStorage.getItem('players');
            return players ? JSON.parse(players) : [];
        }

        // Función para guardar un jugador en localStorage
        // function savePlayer(name, score) {
        //     let players = getPlayersFromStorage();

        //     // Buscar si el jugador ya existe
        //     let existingPlayer = players.find(player => player.name === name);

        //     if (existingPlayer) {
        //         // Solo actualizar la puntuación si es mayor
        //         if (score > existingPlayer.score) {
        //             existingPlayer.score = score;
        //         }
        //     } else {
        //         // Agregar nuevo jugador con la fecha actual
        //         players.push({
        //             name,
        //             score,
        //             date: new Date().toLocaleDateString() // Guardar la fecha de registro
        //         });
        //     }

        //     // Guardar en localStorage
        //     localStorage.setItem('players', JSON.stringify(players));

        //     // Actualizar tabla de puntuaciones
        //     updateScoreTable();
        // }

        // // Función para actualizar la tabla de puntuaciones
        // function updateScoreTable() {
        //     let players = getPlayersFromStorage();

        //     // Ordenar por puntuación de mayor a menor
        //     players.sort((a, b) => b.score - a.score);

        //     // Seleccionar el contenedor donde se insertará la tabla
        //     let scoreContainer = document.querySelector('.col-lg-4 .box');
        //     scoreContainer.innerHTML = `<h3>Puntuaciones</h3>
        //                         <table class="table table-dark">
        //                             <thead>
        //                                 <tr>
        //                                     <th class="fs-2">Nombre</th>
        //                                     <th class="fs-2">Puntuación</th>
        //                                     <th class="fs-2">Fecha de Registro</th> <!-- Nueva columna -->
        //                                 </tr>
        //                             </thead>
        //                             <tbody>
        //                             ${players.map(player => `
        //                                 <tr class="fs-4">
        //                                     <td>${player.name}</td>
        //                                     <td>${player.score}</td>
        //                                     <td>${player.date || 'N/A'}</td> <!-- Mostrar 'N/A' si no tiene fecha -->
        //                                 </tr>`).join('')}
        //                             </tbody>
        //                         </table>`;
        // }

        function ControlsScene() {
            Phaser.Scene.call(this, { key: 'ControlsScene' });
        }

        ControlsScene.prototype = Object.create(Phaser.Scene.prototype);
        ControlsScene.prototype.constructor = ControlsScene;

        ControlsScene.prototype.create = function () {
            this.add.text(300, 150, 'Controles', { fontSize: '32px', fill: '#fff' });
            this.add.text(250, 250, 'Usa las flechas para moverte\nEspacio para saltar', { fontSize: '20px', fill: '#fff' });

            this.add.text(350, 400, 'Volver', { fontSize: '24px', fill: '#ff0' })
                .setInteractive()
                .on('pointerdown', () => this.scene.start('MenuScene'));
        };

        function CreditsScene() {
            Phaser.Scene.call(this, { key: 'CreditsScene' });
        }

        CreditsScene.prototype = Object.create(Phaser.Scene.prototype);
        CreditsScene.prototype.constructor = CreditsScene;

        CreditsScene.prototype.create = function () {
            this.add.text(300, 150, 'Créditos', { fontSize: '32px', fill: '#fff' });
            this.add.text(250, 250, 'Juego creado por: Tu Nombre', { fontSize: '20px', fill: '#fff' });

            this.add.text(350, 400, 'Volver', { fontSize: '24px', fill: '#ff0' })
                .setInteractive()
                .on('pointerdown', () => this.scene.start('MenuScene'));
        };

        function savePlayer(name, score) {
            let players = getPlayersFromStorage();

            // Buscar si el jugador ya existe
            let existingPlayer = players.find(player => player.name === name);

            if (existingPlayer) {
                // Solo actualizar la puntuación si es mayor
                if (score > existingPlayer.score) {
                    existingPlayer.score = score;
                }
            } else {
                // Agregar nuevo jugador con la fecha actual
                players.push({
                    name,
                    score,
                    date: new Date().toLocaleDateString() // Guardar la fecha de registro
                });
            }

            // Guardar en localStorage
            localStorage.setItem('players', JSON.stringify(players));

            // Actualizar tabla de puntuaciones
            updateScoreTable();
        }

        // Función para actualizar la tabla de puntuaciones
        function updateScoreTable() {
            let players = getPlayersFromStorage();

            // Ordenar por puntuación de mayor a menor
            players.sort((a, b) => b.score - a.score);

            // Seleccionar el contenedor donde se insertará la tabla
            let scoreContainer = document.querySelector('.col-lg-4 .box');
            scoreContainer.innerHTML = `<h3>Puntuaciones</h3>
                                <table class="table table-dark">
                                    <thead>
                                        <tr>
                                            <th class="fs-2">Nombre</th>
                                            <th class="fs-2">Puntuación</th>
                                            <th class="fs-2">Fecha de Registro</th> <!-- Nueva columna -->
                                        </tr>
                                    </thead>
                                    <tbody>
                                    ${players.map(player => `
                                        <tr class="fs-4">
                                            <td>${player.name}</td>
                                            <td>${player.score}</td>
                                            <td>${player.date || 'N/A'}</td> <!-- Mostrar 'N/A' si no tiene fecha -->
                                        </tr>`).join('')}
                                    </tbody>
                                </table>`;
        }

        function GameScene() {
            Phaser.Scene.call(this, { key: 'GameScene' });
        }

        GameScene.prototype = Object.create(Phaser.Scene.prototype);
        GameScene.prototype.constructor = GameScene;

        GameScene.prototype.preload = function () {
            this.load.image('nextLevelButton', 'assets/nextLevelButton.png');
            this.load.image('menuButton', 'assets/menuButton.png');

            this.load.image('sky', 'assets/sky.png');
            this.load.image('ground', 'assets/platform.png');
            this.load.image('mountain', 'assets/mountain.png');
            this.load.image('star', 'assets/star.png');
            this.load.image('bomb', 'assets/bomb.png');
            this.load.image('specialItem', 'assets/starPlus.png');
            this.load.spritesheet('dude', 'assets/dude.png', { frameWidth: 32, frameHeight: 48 });
            this.load.spritesheet('dude1', 'assets/dude1.png', { frameWidth: 32, frameHeight: 48 });
        };

        GameScene.prototype.create = function () {
            // Hacer el nivel mucho más largo
            let levelWidth = this.sys.game.config.width * 4; // 4 veces el ancho de la pantalla
            // Mapear 'player1' y 'player2' a sus respectivas spritesheets

            // Crear fondo infinito con tileSprite
            this.sky = this.add.tileSprite(0, 0, this.sys.game.config.width, this.sys.game.config.height, 'sky')
                .setOrigin(0, 0)
                .setScrollFactor(0) // Hace que se quede fijo en la cámara
                .setDepth(-3); // Detrás de todo

            // Crear montañas de fondo con tileSprite
            this.mountains = this.add.tileSprite(0, this.sys.game.config.height - 200, this.sys.game.config.width, 200, 'mountain')
                .setOrigin(0, 1)
                .setScrollFactor(0.5) // Se mueve más lento que el jugador para efecto de parallax
                .setDepth(-2); // Detrás del jugador, pero delante del cielo

            let characterMap = {
                player1: 'dude',
                player2: 'dude1'
            };

            // Obtener la spritesheet correcta
            let selectedCharacter = localStorage.getItem('selectedCharacter') || 'dude';
            let characterKey = characterMap[selectedCharacter] || 'dude';  // Valor por defecto
            // Obtener el personaje seleccionado desde localStorage



            // Agregar el jugador a la escena con la imagen correcta
            // this.player = this.physics.add.sprite(100, 450, selectedCharacter);
            // this.player.setBounce(0.2);
            // this.player.setCollideWorldBounds(true);

            this.isGameOver = false; // El juego empieza en falso

            this.add.image(400, 300, 'sky');


            // Crear plataformas
            let platforms = this.physics.add.staticGroup();
            platforms.create(400, 568, 'ground').setScale(2).refreshBody();
            platforms.create(800, 568, 'ground').setScale(2).refreshBody();
            platforms.create(1200, 568, 'ground').setScale(2).refreshBody();
            platforms.create(1600, 568, 'ground').setScale(2).refreshBody();
            platforms.create(2000, 568, 'ground').setScale(2).refreshBody();
            platforms.create(2400, 568, 'ground').setScale(2).refreshBody();
            platforms.create(2800, 568, 'ground').setScale(2).refreshBody();
            platforms.create(3200, 568, 'ground').setScale(2).refreshBody();
            platforms.create(3600, 568, 'ground').setScale(2).refreshBody();
            platforms.create(4000, 568, 'ground').setScale(2).refreshBody();
            platforms.create(800, 450, 'ground');
            platforms.create(1200, 350, 'ground');
            platforms.create(1600, 250, 'ground');
            platforms.create(2000, 400, 'ground');
            platforms.create(2500, 500, 'ground');
            platforms.create(2500, 500, 'ground');

            this.specialItemGroup = this.physics.add.group();

            this.player = this.physics.add.sprite(100, 450, characterKey);
            this.player.setBounce(0.2);
            this.player.setCollideWorldBounds(true);


            if (!this.player) {
                console.error("Error: this.player no se ha inicializado correctamente");
            }
            // Habilitar la colisión entre el jugador y las plataformas
            this.physics.add.collider(this.player, platforms);

            this.anims.create({
                key: 'left',
                frames: this.anims.generateFrameNumbers(characterKey, { start: 0, end: 3 }),
                frameRate: 10,
                repeat: -1
            });

            this.anims.create({
                key: 'turn',
                frames: [{ key: characterKey, frame: 4 }],
                frameRate: 20
            });

            this.anims.create({
                key: 'right',
                frames: this.anims.generateFrameNumbers(characterKey, { start: 5, end: 8 }),
                frameRate: 10,
                repeat: -1
            });

            this.cursors = this.input.keyboard.createCursorKeys();

            this.stars = this.physics.add.group({
                key: 'star',
                repeat: 11,
                setXY: { x: 12, y: 0, stepX: 70 }
            });

            this.stars.children.iterate(function (child) {
                child.setBounceY(Phaser.Math.FloatBetween(0.4, 0.8));
            });

            this.bombs = this.physics.add.group();
            this.spawnBombs(3);

            // Vidas
            this.lives = 3;

            // Contenedor en el HTML donde se mostrarán las imágenes de las vidas
            this.livesContainer = document.getElementById("lives-container");

            // Cargar las imágenes de las vidas
            this.updateLivesUI();

            // Grupo de disparos
            this.bullets = this.physics.add.group();

            // Puntuación
            this.score = parseInt(localStorage.getItem('score')) || 0;
            this.scoreText = this.add.text(16, 16, `Score: ${this.score}`, { fontSize: '32px', fill: '#000' });

            this.physics.add.collider(this.player, platforms);
            this.physics.add.collider(this.stars, platforms);
            this.physics.add.collider(this.bombs, platforms);
            this.physics.add.overlap(this.player, this.stars, this.collectStar, null, this);
            this.physics.add.collider(this.player, this.bombs, this.hitBomb, null, this);
            this.physics.add.collider(this.specialItemGroup, platforms);



            // Tecla para disparar
            this.spaceKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);
            this.physics.add.overlap(this.bullets, this.bombs, this.hitEnemy, null, this);

            // Hacer que la camara siga al jugador
            this.cameras.main.startFollow(this.player);
            this.cameras.main.setBounds(0, 0, levelWidth, this.sys.game.config.height);

            // Asegurar que la cámara cubra todo el nivel
            this.cameras.main.setBounds(0, 0, levelWidth, this.sys.game.config.height);

            // Asegurar que el jugador pueda moverse dentro de los límites del mundo
            this.physics.world.setBounds(0, 0, levelWidth, this.sys.game.config.height);
            this.lastSpawnX = this.player.x; // Inicializar la última posición de spawn


        };

        // ✅ **Función para disparar hacia la dirección del jugador**
        GameScene.prototype.shoot = function () {
            if (this.isGameOver) return;

            let bullet = this.bullets.create(this.player.x, this.player.y, 'bomb');
            bullet.setScale(0.5);
            bullet.body.allowGravity = false;

            // Determinar la dirección del disparo
            let direction = this.player.anims.currentAnim.key === 'left' ? -1 : 1;
            bullet.setVelocityX(400 * direction);
        };

        GameScene.prototype.update = function () {

            if (!this.player || this.isGameOver) return;


            this.sky.tilePositionX = this.cameras.main.scrollX;
            this.mountains.tilePositionX = this.cameras.main.scrollX * 0.5;


            let distanceThreshold = 500; // Cada cuántos píxeles se generan estrellas y bombas
            let nextSpawnX = this.lastSpawnX + distanceThreshold;

            if (this.player.x > nextSpawnX) {
                this.lastSpawnX = this.player.x;

                // Generar una nueva estrella
                let starX = this.player.x + Phaser.Math.Between(100, 300);
                let starY = Phaser.Math.Between(50, 300);
                let newStar = this.stars.create(starX, starY, 'star');
                newStar.setBounceY(Phaser.Math.FloatBetween(0.4, 0.8));
                console.log("Nueva estrella");

                // Generar una nueva bomba
                let bombX = this.player.x + Phaser.Math.Between(200, 400);
                let bomb = this.bombs.create(bombX, 16, 'bomb');
                bomb.setBounce(1);
                bomb.setCollideWorldBounds(true);
                bomb.setVelocity(Phaser.Math.Between(-200, 200), 20);
                console.log("Nueva bomba");
            }

            if (this.score >= 50 && !this.isGameOver) {
                this.showCongratulations();
                return;
            }


            if (this.cursors.left.isDown) {
                this.player.setVelocityX(-160);
                this.player.anims.play('left', true);
            } else if (this.cursors.right.isDown) {
                this.player.setVelocityX(160);
                this.player.anims.play('right', true);
            } else {
                this.player.setVelocityX(0);
                this.player.anims.play('turn');
            }

            if (this.cursors.up.isDown && this.player.body.touching.down) {
                this.player.setVelocityY(-330);
            }

            // Detectar disparo
            if (Phaser.Input.Keyboard.JustDown(this.spaceKey)) {
                this.shoot();
            }

            // ---- LÓGICA PARA APARECER EL OBJETO ESPECIAL ---
            if (!this.hasSpawnedSpecialItem && this.player.x >= 500) {
                this.spawnSpecialItem();
                this.hasSpawnedSpecialItem = true;
            }

            this.specialItemGroup.children.iterate(specialItem => {
                if (specialItem.active && specialItem.countdownText) {
                    specialItem.countdownText.x = specialItem.x;
                    specialItem.countdownText.y = specialItem.y - 50;
                }
            });
        };

        GameScene.prototype.spawnSpecialItem = function () {
            // Crea el ítem un poco adelante del jugador para que sea visible
            let x = this.player.x + Phaser.Math.Between(200, 400);
            let y = Phaser.Math.Between(50, 300);

            // Crea el sprite y lo añade al grupo
            let specialItem = this.specialItemGroup.create(x, y, 'specialItem');

            // Ajusta físicas
            specialItem.setBounce(0.5);
            specialItem.setCollideWorldBounds(true);
            // Haz que colisione con las plataformas
            this.physics.add.collider(specialItem, this.platforms);

            // Detectar colisión/solapamiento con el jugador
            this.physics.add.overlap(this.player, specialItem, this.collectSpecialItem, null, this);

            // --- CONTADOR SOBRE EL ÍTEM ---
            let timeLeft = 5; // (5 segundos)
            let countdownText = this.add.text(
                specialItem.x,
                specialItem.y - 50,
                timeLeft,
                { fontSize: '20px', fill: '#fff' }
            ).setOrigin(0.5);

            // Guarda la referencia en el propio ítem para manipularlo luego
            specialItem.countdownText = countdownText;
            specialItem.timeLeft = timeLeft;

            // Cada segundo, disminuimos el contador
            this.time.addEvent({
                delay: 1000,
                callback: () => {
                    // Si el ítem ya no existe (recogido o destruido), no hacemos nada
                    if (!specialItem.active) return;

                    specialItem.timeLeft--;
                    specialItem.countdownText.setText(specialItem.timeLeft);

                    if (specialItem.timeLeft <= 0) {
                        // Se acabó el tiempo: destruir ítem y su texto
                        specialItem.destroy();
                        specialItem.countdownText.destroy();
                        console.log("El objeto especial desapareció por tiempo.");
                    }
                },
                repeat: 4 // Repetimos 4 veces. (0 -> 5s totales)
            });
        };

        GameScene.prototype.collectSpecialItem = function (player, specialItem) {
            // Desactivarlo inmediatamente (ya no colisiona)
            specialItem.disableBody(true, true);

            // Destruir el texto si existe
            if (specialItem.countdownText) {
                specialItem.countdownText.destroy();
            }

            // Sumar 100 puntos al marcador
            this.score += 100;
            this.scoreText.setText(`Score: ${this.score}`);

            // (Opcional) Guardar en localStorage
            let playerName = localStorage.getItem('playerName') || "Jugador";
            savePlayer(playerName, this.score);

            console.log("¡Recogiste el objeto especial y ganaste 100 puntos!");
        };

        GameScene.prototype.updateLivesUI = function () {
            // Limpiar el contenedor antes de volver a renderizar las vidas
            this.livesContainer.innerHTML = "";

            // Agregar una imagen por cada vida restante
            for (let i = 0; i < this.lives; i++) {
                let img = document.createElement("img");
                img.src = "assets/bomb.png"; // Ruta correcta de la imagen de vida
                img.classList.add("life-icon"); // Clase CSS para darle estilo
                this.livesContainer.appendChild(img);
            }
        };

        // Función cuando el jugador es golpeado por una bomba
        GameScene.prototype.hitBomb = function (player, bomb) {
            // Reducir vida
            this.lives -= 1;

            // Actualizar la UI de vidas
            this.updateLivesUI();

            // Si las vidas llegan a 0, terminar el juego
            if (this.lives <= 0 && !this.isGameOver) {
                this.gameOver();
                console.log("Game Over");
            }
        };

        //Colision de las balas a los enemigos
        GameScene.prototype.hitEnemy = function (bullet, bomb) {
            console.log("Impacto");

            bullet.destroy(); // Eliminar la bala

            if (bomb.health === undefined) {
                bomb.health = 5; // Asignar vida
            }

            bomb.health -= 1;

            //Cambiar color al recibir daño 
            bomb.setTint(0xff0000);
            setTimeout(() => {
                bomb.clearTint(); // Volver al color normal después de 200ms
            }, 200);

            if (bomb.health <= 0) {
                bomb.destroy();
                this.score += 20;
                this.scoreText.setText(`Score: ${this.score}`);
            }
        };

        // Función para generar bombas en posiciones aleatorias
        GameScene.prototype.spawnBombs = function () {
            for (let i = 0; i < 3; i++) { // Genera 2 bombas cada vez
                let x = Phaser.Math.Between(100, 700);
                let bomb = this.bombs.create(x, 16, 'bomb');
                bomb.setBounce(1);
                bomb.setCollideWorldBounds(true);
                bomb.setVelocity(Phaser.Math.Between(-200, 200), 20);
                bomb.health = 5;
            }
        };

        // Funcion para guardar la puntuación en localStorage
        GameScene.prototype.collectStar = function (player, star) {
            star.disableBody(true, true);
            this.score += 10;

            // Guardar o actualizar la puntuación en localStorage
            let playerName = localStorage.getItem('playerName') || "Jugador";
            savePlayer(playerName, this.score);

            this.scoreText.setText(`Score: ${this.score}`);

            //Generar nuevas estrellas
            if (this.stars.countActive(true) === 0) {
                this.stars.children.iterate(child => { child.enableBody(true, child.x, 0, true, true); });
                this.spawnBombs();
            }
        };

        GameScene.prototype.gameOver = function () {
            if (this.isGameOver) return; // Evita llamadas múltiples
            this.isGameOver = true; // Marcar el estado de game over

            // Pausa el jugador
            this.physics.pause();
            this.player.setTint(0xff0000);
            this.player.anims.play('turn');

            // Eliminar controles
            this.cursors.left.reset();
            this.cursors.right.reset();
            this.cursors.up.reset();

            // Mostrar el texto de Game Over
            let gameOverText = this.add.text(400, 200, 'GAME OVER', { fontSize: '48px', fill: '#f00' }).setOrigin(0.5);

            // Botón de reinicio
            let restartButton = this.add.text(400, 300, 'Reintentar', { fontSize: '32px', fill: '#0f0' })
                .setInteractive()
                .on('pointerdown', () => {

                    this.scene.restart();          // Reiniciar escena
                });


            // Botón de menú
            let menuButton = this.add.text(400, 350, 'Menú Principal', { fontSize: '32px', fill: '#ff0' })
                .setInteractive()
                .setOrigin(0.5)
                .on('pointerdown', () => {
                    this.scene.start('MenuScene');
                });
        };

        GameScene.prototype.showCongratulations = function () {
            this.isGameOver = true;  // Bloquear el juego para que no continúe mientras se muestra el mensaje

            // Detener la física y las animaciones
            this.physics.pause();
            this.player.setTint(0x00ff00);  // Puedes cambiar el color del jugador para dar efecto de "felicitación"

            // Mostrar el mensaje de felicitaciones
            let congratulationsText = this.add.text(400, 200, '¡Felicidades! Has alcanzado 1000 puntos.', {
                fontSize: '48px',
                fill: '#fff'
            }).setOrigin(0.5);

            // Botón de siguiente nivel
            let nextLevelButton = this.add.image(400, 300, 'nextLevelButton').setInteractive();
            nextLevelButton.on('pointerdown', () => {
                this.startNextLevel();
            });

            // Botón de volver al menú
            let menuButton = this.add.image(400, 400, 'menuButton').setInteractive();
            menuButton.on('pointerdown', () => {
                this.goToMainMenu();
            });
        };

        GameScene.prototype.startNextLevel = function () {
            this.scene.start('NextLevel');
        };

        GameScene.prototype.goToMainMenu = function () {
            this.scene.start('MenuScene');
        };

        window.onload = function () {
            updateScoreTable();
            var music = document.getElementById('backgroundMusic');
            music.play();
        };
    </script>


</body>

</html>